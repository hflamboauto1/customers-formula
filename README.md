# Higher level customers pillar for saltstack

**Lecteurs francophones:** n'hésitez pas à demander une traduction si nécessaire, je la produirai.  :smirk:

This customers formula for salt is designed to produce derivated pillar configuration files. See [diagram](https://github.com/opensource-expert/customers-formula/blob/master/doc/pillar_diagram.pdf)

![diagram customers pillar](https://github.com/opensource-expert/customers-formula/raw/master/doc/pillar_diagram.png) 

It will generate some more pillar files on the saltmaster.

It is a **Proof of Concept** and could porbably be achieved with [`ext_pillar`](https://docs.saltstack.com/en/latest/topics/development/external_pillars.html). The main advantages over ext_pillar are:

* the resulting pillar can be put under version control (git)
* you can stop at pillar generation (git diff)
* you can achieve some change detection too, as you have acces to both previously generated pillar and new values.

## The Context

We would like to handle `customers` for a web agency. So they will be defined at higher level in `pillar/customers.sls`

See: [`pillar.example`](pillar.example)

The `init.sls` state handles the pillar generation, producing pillar for other formulas:

* [apache-formula](https://github.com/saltstack-formulas/apache-formula)
* [mysql-formula](https://github.com/saltstack-formulas/mysql-formula)
* [users-formula](https://github.com/saltstack-formulas/users-formula)
* custom salt states for managing DNS zones with PowerDNS
* more



## Source customers pillar

It looks like:

~~~yaml
customers_top: wsf
wsf:
  global:
    webmaster: someone@webmaster.com
    dbserver: datbase.domain.com
    webserver: web.domain.com
  customers:
    client1:
      domain_name: client1-domain.fr
      webmaster: client1@webmaster.com
      enabled: true
      delete: false
      # service to configure for this customer
      services:
        - webhost
        - dns
        - db
        # sftp access only is managed by a custom state, but it generate user-formula pillar
        - sftp
    # client2 with some default values
    client2:
      domain_name: more-domain.com
      enabled: true
      services:
        - webhost
        - dns
    client3:
      domain_name: somedomain.fr
      enabled: true
      # default, delete: false
      services:
        - webhost
        - dns
        - db
        - sftp
~~~

## Produced mysql-formula pillar

For this pillar above, we expect to generate users for having access to mariaDB.

Here is a *representation* of the merged output of `pillar/auto/mysql_db.sls` + `pillar/auto/mysql_users.sls`
Password management dosen't work that way, but it is just for description here. This pillar example
is on the format expected by [mysql-formula](https://github.com/saltstack-formulas/mysql-formula).

~~~yaml
## generated yaml password database See: customers_passwords.py
{% import_yaml "/path/to/pillar/auto/managed_password.yaml" as pass with context %}
mysql:
  # Managed databases for customers
  # those databases are generated by the state/customers/init.sls
  database:
    - client1
    - client2
    - client3
  # [ merged… ]
  # Managed mariaDB users for customers
  # those mariaDB users are generated by the state/customers/init.sls
  # passwords are handled externally by a custom python script.
  user:
    client1:
      password: "{{ pass['client1']['mysql'] }}"
      hosts:
        - localhost
      databases:
        - database: client1
          grants: ['all privileges']
    client2:
      password: "{{ pass['client2']['mysql'] }}"
      hosts:
        - localhost
      databases:
        - database: client2
          grants: ['all privileges']
    client3:
      password: "{{ pass['client3']['mysql'] }}"
      hosts:
        - localhost
      databases:
        - database: client3
          grants: ['all privileges']
~~~

## install in the pillar

### `pillar/top.sls`

~~~yaml
# vim: set ft=yaml:
#
# Pillar top inclusions
base:
  '*':
    # top level definition for customers avail to all rules
    - customers
  'db*':
    # pillar are merged
    # your local common config of mysql-formula
    - mysql.defaults
    # database and users are split into 2 pillar files
    - auto.mysql_db
    - auto.mysql_users
~~~

### use formula `state` and configure

Put the formula code in your `file_roots:`, in `/etc/salt/master`

* `pillar_dir` [line 10](customers/init.sls#L10) (TODO: define it in pillar)


`target_dir` is combined with [line 11](customers/init.sls#L11) `customers_top:customers_dir` pillar value.

* If `pillar_dir` is `/srv/pillar` and `customers_top:customers_dir` is not set it will be: `/srv/pillar/auto`. 
* If `customers_top:customers_dir` is `some_value` it will be: `/srv/pillar/some_value/auto`. (if you need more than one customer pool)

## Generate pillar
run on the master  (with care  :simple_smile: ) it creates files in your pillar `target_dir` (See above)

~~~bash
salt-call state.apply customers
~~~

This should create the `auto/` folder and files inside, which need be propagated that way:

~~~bash
salt '*' saltutil.refresh_pillar
~~~

### More usages

Usage: (on the saltmaster)

Only generate pillar

~~~bash
salt-call state.apply customers
~~~

Verify with git
~~~bash
salt-call state.apply customers
cd to/target_dir
git diff # double check
~~~

Propagate to mininons
~~~bash
salt '*' saltutil.refresh_pillar
~~~

Check some values, by minion, you need to add appropriate `pillar/top.sls` `auto.generated_file*` of course.

~~~bash
salt 'db*' config.get mysql:user
salt 'web*' config.get apache:sites
salt 'web*' config.get users
~~~

run rules based on the generated pillar (For example with mysql-formula)

~~~bash
salt 'db*' state.apply mysql.user
~~~

commit changes:
~~~bash
cd to/target_dir
git commit -a
~~~

generating an alternative customers config, select your `customers_top` and match your pillar `customers.sls` dictionnary key.

~~~bash
salt-call state.apply customers pillar='{"customers_top" : "another_value" }'
~~~

## orchestration

See: https://docs.saltstack.com/en/latest/topics/orchestrate/orchestrate_runner.html#orchestrate-runner

Some more examples will be committed in the doc later.

~~~bash
salt-run state.orch orch.all
~~~

Only the pillar:

~~~bash
salt-run state.orch orch.pillar
~~~

(TODO: add files in this repos)

`orch/pillar.sls`:

~~~yaml
genrate-customers-pillar:
  salt.function:
    - tgt: 'salt*'
    - name: state.apply
    - arg:
      - customers
    - kwarg:
       pillar:
          customers_top: wsf
    #- failhard: True

synchronize-pillar:
  salt.function:
    - name: saltutil.refresh_pillar
    - tgt: '*'
~~~


`orch/all.sls`
~~~yaml
include:
  - orch.pillar

make-world:
  salt.state:
    - tgt: '*'
    - highstate: True
~~~

## password generator
See the code [customers_passwords.py](customers/customers_passwords.py)

* It depends on [pwqgen](http://www.openwall.com/passwdqc/) debian package: `passwdqc`
* Can be tested online [here](https://pwqgen.herokuapp.com/).

### algorithm
* reads `customers.sls` as a yaml file, and get the `customers` subkey.
* reads `managed_passwords.yaml` as a yaml file
* compare missing user without passwords and add them to `managed_passwords.yaml`
* generate shadows hashes for unix passwords
* it doesn't regenerate passwords already present.
 

## TODO

manage password with https://clinta.github.io/random-local-passwords/ passwordstore
